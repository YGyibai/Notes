### 外观模式 	Facade Pattern

**定义：** 又叫门面模式，提供了统一的接口，来访问子系统的一群接口

外观模式定义了一个高层接口，让子系统更容易使用

**类型：**结构型 

#### 适用场景

- 子系统越来越复杂，曾加外观模式提供简单调用接口
- 构建多层系统结构，利用外观对象作为每层的入口，简化层间调用

#### 优点

- 简化了调用过程，无须深入了解子系统，防止带来风险
- 减少系统依赖，松散耦合
- 更好的划分访问层次
- 符合迪米特法则，即最少知道原则

#### 缺点

- 增加子系统，扩展子系统行为容易引起风险
- 不符合开闭原则 

### 装饰者模式	 Decorator Pattern

**定义：**在不改变原有对象的基础之上，将功能附加到对象上

提供了比继承更有弹性的替代方案（扩展原有对象功能）

**类型：**结构型

#### 适用场景

- 拓展一个功能或给一个类添加附加职责
- 动态的给一个对象添加功能，这些功能可以动态的撤销 

#### 优点

- 继承的有力补充，比继承灵活，不改变原有对象的情况下给一个对象扩展功能
- 通过使用不同装饰类以及这些装饰类的排列组合，可以实现不同效果 

- 符合开闭原则

#### 缺点

- 会出现更多的类，更多的代码，增加程序复杂性
- 动态装饰时，多层装饰时会更复杂

### 适配器模式 	Adapter Pattern

**定义：**将类的一个接口转换成客户期望的另一个接口

使原本不兼容的类一起工作

**类型：**结构型

#### 适用场景

- 已经存在的类，他的方法和需求不匹配时（方法结构相同或者相似）
- 不是软件设计阶段考虑的设计模式，是随着软件维护，由于不同产品、不同厂家造成功能相似而接口不相同情况下的解决方案  

#### 优点

- 提高类的透明性和复用，现有的类复用但不需要改变
- 目标类和适配器类解耦，提高程序扩展性
- 符合开闭原则

#### 缺点

- 适配器编写过程需要全盘考虑，可能增加系统的复杂性
- 增加系统代码可读的难度

对象适配器模式 

类适配器模式

### 享元模式  		Flyweight Pattern

**定义：**提供了减少对象数量从而改善应用所需的对象结构的方式

运用共享技术有效的支持大量细粒度的对象

**类型：**结构型

#### 适用场景

- 常常应用于系统底层的开发，以便于解决系统的性能问题
- 系统有大量相似对象、需要缓冲池的场景 

#### 优点

- 减少对象的创建，降低内存中对象的数量，降低系统的内存，提高效率
- 减少内存之外其他资源的占用

#### 缺点

- 关注内/外部状态、关注线程安全问题
- 使系统、逻辑 的复杂化

###  组合模式		Composite Pattern

**定义：**将对象组成树形结构以表示”部分-整体“的层次结构

组合模式使客户端对单个对象和组合对象保持一致的方式处理

**类型：**结构型

#### 适用场景

- 希望客户端可以忽略组合对象和单个对象的差异时 
- 处理树形结构时

#### 优点

- 清楚的定义分层次的复杂对象，表示对象的全部或部分层次
- 让客户端忽略层次的差异，方便对整个层次结构进行控制
- 简化客户端代码
- 符合开闭原则

#### 缺点

- 限制类型时比较复杂
- 使设计变得更加抽象 

#### 相关设计模式

组合模式——访问者模式

### 桥接模式		Bridge Pattern

**定义：**将抽象部分和具体实现部分分离，使他们可以独立的变化

通过组合的方式建立两个类之间的联系，而不是继承

**类型：**结构型

#### 适用场景

- 抽象和具体实现之间增加更多的灵活性
- 一个类存在两个（多个）独立变化的维度，且这两个（多个）维度都需要进行独立的拓展
- 不希望使用继承，或因为多层继承导致系统类的个数剧增

#### 优点

- 分离抽象部分及其 具体实现部分
- 提高了系统的可扩展性
- 符合开闭原则

#### 缺点

- 增加了系统的理解和设计难度

-  需要正确地识别系统中两个独立变化的维度

#### 相关设计模式

桥接模式和组合模式

桥接模式和适配器模式