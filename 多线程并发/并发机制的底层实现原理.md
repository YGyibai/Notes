## volatile的应用

### volatile的定义与实现原理

**功能：**

> 1. 在并发编程中，volatile和synchronized同等重要，它是轻量的synchronized，在多处理器开发中**保证了共享变量的“可见性”**，即线程A修改了共享变量，线程B能读到这个值
>
> 2. volatile使用得当的话，执行成本更低，因为它不会引起上下文的切换和调度
>
> 3. Java编程语言，允许线程访问共享变量，但是为了保证共享变量能够被准确一致性的更新，线程应该确保通过排他锁单独的获取这个变量，此外Java提供了volatile可以保证所有线程看到的变量的值是一致的

**定义：**

volatile 是一个类型修饰符。volatile 的作用是作为指令关键字，确保本条指令不会因编译器的优化而省略

**实现原理：**

  `instance = new Instancce() //instance是volatile变量` 

在生成汇编代码时会在volatile修饰的共享变量进行写操作的时候会多出**Lock前缀的指令**

**Lock前缀的指令在多核处理器下会引发了两件事情**：（也是volatile的实现原则）

1.将当前处理器缓存行的数据写回到系统内存

2.这个写回内存的操作会使得其他CPU里缓存了该内存地址的数据无效

**volatile的实现原则：**

- Lock前缀指令会引起处理器缓存回写到内存
- 一个处理器的缓存回写到内存会导致其他处理器的缓存失效

>  为了提高处理速度，处理器不直接和内存通信，而是首先将内存的数据读取到缓存（L1,L2..）后再操作，这样就有一个问题，操作完不知道何时会写回到内存
>
>  如果对声明了volatile的变量进行写操作，JVM首先向处理器发送一条Lock前缀指令，**将这个变量所在缓存行的数据写回到系统内存**，那么对导致另外一个问题
>
>  如果其他处理器缓存的值还是旧值，再次执行时同样会出现问题，因此在多处理器下，为了保证各个处理器缓存数据的一致性，就**必须实现缓存一致性协议**
>
>  **缓存一致性机会阻止同时修改2个以上处理器缓存的内存区域数据** 
>
>  每个处理器通过嗅探系统总线的数据来检查自己的缓存数据是否过期，当处理器发现自己缓存行对应的内存地址被修改了，就会置为无效
>
>  同时当处理器对这个数据再次进行操作的时候，会重新从系统内存中把数据读取到处理器缓存中，从而实现缓存一致性（通过MESI控制协议实现）

