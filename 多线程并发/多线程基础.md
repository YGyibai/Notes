[TOC]



## 基本概念

​	**1.程序：**指令和数据的有序集合，其本身没有任何意义，是一个静态的概念

​	**2.进程：**执行程序的一次执行过程，是一个动态的概念。每个进程在内存中都有一块独立的内存空间。

​	**3.线程：**通常一个进程中可以包含若干个线程，一个进程中至少有一个线程。线程是CPU调度和执行的单位

​	**4.并行：** 多个事件在同一个时间点同时发生，是真正的同时发生；

​	**5.并发：**多个事件在同一时间内在宏观上同时发生，而在微观上是CPU在多个事件上来回切换，但切换时间很快，不能被人眼捕获，因此在一段人类可以观察到的时间内，多个事件是同时发生的；

**多线程并发：**其实就是运行中各个进程轮流获取CPU的使用权来分别执行各自的任务；在多进程的环境中，会有多个线程处于等待CPU使用权的状态中，为这些等地中的线程分配CPU的使用权的操作就成为线程调度。

**线程调度：**计算机单个CPU在任意时刻只能执行一条计算机指令，每个进程只有获得CPU使用权才能执行相关指令；

**线程调度分为抢占式调度和分时调度**

​		**抢占式调度：**多个线程在瞬间抢占CPU资源，谁抢到谁就运行，有更多的随机性；

​		**分时调度：**为等待中的多个线程平均的分配CPU时间片

Java的多线程中线程调度就是使用抢占式调度的

## 基础线程机制

#### Daemon守护线程

守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分。当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。

在线程启动之前使用setDaemon()方法可以将一个线程设置为守护线程

```java
public static void main(String[] args){
	Thread thread=new Thread(new MyRunnable());
	thread.setDaemon(true);
}
```

#### sleep

```text
属于线程Thread的方法；
让线程暂缓执行，等待预计时间之后再恢复；
交出CPU使用权，不会释放锁；
进入阻塞状态TIME_WAITGING，睡眠结束变为就绪Runnable；
```

#### yield

```text
属于线程Thread的方法；
暂停当前线程的对象，去执行其他线程；
交出CPU使用权，不会释放锁，和sleep类似；
作用：让相同优先级的线程轮流执行，但是不保证一定轮流；
注意：不会让线程进入阻塞状态，直接变为就绪Runnable，只需要重新获得CPU使用权；
```

#### join

```text
属于线程Thread的方法；
在主线程上运行调用该方法，会让主线程休眠，不会释放已经持有的对象锁；
让调用join方法的线程先执行完毕，再执行其他线程；
```

#### wait

```text
属于Object的方法；
当前线程调用对象的wait方法，会释放锁，进入线程的等待队列；
需要依靠notify或者notifyAll唤醒，或者wait(timeout)时间自动唤醒；
```

#### notify

```text
属于Object的方法；
唤醒在对象监视器上等待的单个线程，选择是任意的；
```

#### notifyAll

```text
属于Object的方法；
唤醒在对象监视器上等待的全部线程；
```

### 线程的调度模型 

- 分时调度模型：所有线程轮流使用CPU
- 抢占式调度：一起抢，谁抢到谁用，优先级高的线程，抢到的概率更大一些
- 深入理解jvm这本书提到了一个协同调度模型，线程执行时间由线程本身来控制，执行完成后主动 通知其他线程切换。虽然简单，但是弊端也很大，因为线程执行时间不可控


## 使用线程

 ### 实现Runnable接口

 ### 实现Callable接口

 ### 继承Thread

 ### 实现接口 VS 继承 Thread



## 线程状态

一个线程只能处于一种状态，并且这里的线程状态特指java虚拟机的线程状态，不能反映线程在特定操作系统下的状态

- ### NEW创建状态

    创建后尚未启动

- ### RUNNABLE就绪状态

  ​		正在java虚拟机中运行。但在操作系统层面，它可能处于运行状态，也可能处于等待资源调度（例如处理器资源），资源调度完成就进入运行状态。所以该状态的可运行是指处于就绪状态，具体有没有运行要看底层操作系统的资源调度。     

- ### BLOCKED阻塞状态

  ​		请求获取monitor lock（监视器/锁对象）从而进入 synchronized函数或者代码块，所以处于阻塞状态。要结束该专题进入RUNABLE需要其他线程释放monitor lock。

- ### 无限期等待WAITING

  ​		等待其他线程显示唤醒。

  ​		阻塞和等待的区别在于，阻塞是由于共享资源被其他线程占用而无法获取资源，它是被动的，而WAITING是主动的，它通过调用Object.wait()等方法进入。

  **下面是进入WAITING的方法**

  | 进入方法                                   | 退出方法                             |
  | ------------------------------------------ | ------------------------------------ |
  | 没有设置 Timeout 参数的 Object.wait() ⽅法 | Object.notify() / Object.notifyAll() |
  | 没有设置 Timeout 参数的 Thread.join() 方法 | 被调用的线程执⾏完毕                 |
  | LockSupport.park() 方法                    | LockSupport.unpark(Thread）          |

- ### 限期等待TIMED_WAITING

  ​		无需等待其他线程显示唤醒，在一定时间被系统自动唤醒。

  | 进入方法                               | 退出方法                             |
  | -------------------------------------- | ------------------------------------ |
  | Thread.sleep() ⽅法                    | 时间结束                             |
  | 设置 Timeout 参数的 Object.wait() ⽅法 | Object.notify() / Object.notifyAll() |
  | 设置 Timeout 参数的 Thread.join() 方法 | 时间结束/被调用的线程执行完毕        |
  | LockSupport.parkNanos() ⽅法           | LockSupport.unpark(Thread)           |
  | LockSupport.parkUntil() 方法           | LockSupport.unpark(Thread)           |

- ### TERMINATED结束状态

  ​	可以是线程结束任务之后自⼰结束，或者产⽣了异常⽽结束。
  
## 互斥同步

Java 提供了了两种锁机制来控制多个线程对共享资源的互斥访问，第一个是 JVM 实现的 synchronized， 而另一个是 JDK 实现的 ReentrantLock。

### synchronized

有四种不同的同步块：

1.实例方法

​		作用于同一个对象

2.静态方法

​		作用于整个类（类对象）

3.实例方法中的同步块

​		作用于同一个对象

4.静态方法的同步块

​		作用于整个类（类对象）

### ReentrantLock

ReentrantLock 是 java.util.concurrent(J.U.C)包中的锁。

### 比较

**1.** 锁的实现

synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。

**2.** 性能

新版本 Java 对 synchronized 进⾏了很多优化，例如自旋锁等，synchronized 与 ReentrantLock 大致 相同。

**3.** 等待可中断 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理理其他事情。 ReentrantLock 可中断，而 synchronized 不不行。
 **4.** 公平锁
 公平锁是指多个线程在等待同⼀一个锁时，必须按照申请锁的时间顺序来依次获得锁。
 synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。

 **5.** 锁绑定多个条件
 一个 ReentrantLock 可以同时绑定多个 Condition 对象。

####  使用选择

除非需要使⽤ ReentrantLock 的⾼级功能，否则优先使用 synchronized。这是因为 synchronized 是 JVM 实现的一种锁机制，JVM 原生地⽀持它，⽽ ReentrantLock 不是所有的 JDK 版本都支持。并且使 ⽤用synchronized 不⽤用担心没有释放锁⽽导致死锁问题，因为 JVM 会确保锁的释放。



