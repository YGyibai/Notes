## JMM（Java内存模型）

Java内存模型（简称JMM），是一种虚拟机规范，用于屏蔽各种硬件和操作系统的内存访问，已实现让Java程序在各种平台下都能达到一致的并发效果，JMM决定一个线程对共享变量 的写入何时对另一个线程可见。

### 从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系:

- 线程之间的 **共享变量**存储在**主内存（main memory）**中
- 线程被CPU执行， **每个线程**都有一个  **私有的本地内存**(如**CPU的高速缓存**)，本地内存中存储了该 线程以读/写共享变量的副本。 

- **(重点)本地内存是JMM的一个抽象概念，并不真实存在;它涵盖了**缓存，写缓冲区，寄存器**以及其 他的硬件和编译器优化。

### **那为什么**Java的内存模型规范要这样定义导致出现线程本地内存和主存的值不同步呢?为啥线程 要有自己的本地内存?

答案是利用**缓存**和**改变执行代码顺序**达到程序执行效率优化。

例如下面代码：

```java
int a1 = x;
int a2 = y;
int a3 = x;
```

可能会被转化为：

```java
int a2 = y;
int a1 = x;
int a3 = x;
```

或者是：

```java
int a1 = x;
int a2 = y;
int a3 = a1;
```

这样和最初的代码相比，少读x一次。

关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内

存同步到主内存之间的实现细节，Java内存模型定义了以下八种操作来完成:

**lock****(锁定)**:作用于主内存的变量，把一个变量标识为一条线程独占状态。**

** **unlock(解锁)**:作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可 以被其他线程锁 

**read**(读取)**:作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后 的load动作使用 **load(载入)**:作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的 变量副本中。**

** **use(使用)**:作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机 遇到一个需要使用变量的值的字节码指令时将会执行这个操作。**

** **assign(赋值)**:作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变 量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。 **

store(存储)**:作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随 后的write的操作。**

** **write(写入)**:作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存 的变量中。